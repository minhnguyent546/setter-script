#!/usr/bin/env bash

# generating output files from provided input files
#
# requires:
#   time (not a shell keyword one)
#

declare -r __script_name='setter gen'

if [ -f "${_SETTER_ROOT_DIR}/env/colors.sh" ]; then
  . "${_SETTER_ROOT_DIR}/env/colors.sh" 
fi

input_dir="in"
output_dir="out"
checker="checker.out"
time_command="$(which time 2> /dev/null)" # do not use shell keyword
if [[ -z "$time_command" ]]; then
  printf "%s: 'time' command is required but not found\n" "${__script_name}" >&2
  exit 127
fi

if ! which timeout &> /dev/null; then
  printf "%s: 'timeout' command is required but not found\n" "${__script_name}" >&2
  exit 127
fi

function usage() {
  cat << EOF
Usage: ${__script_name} [options...]

Options:
  -c, --checker <file>      Checker file to run (default: ${checker})
  -i, --input-dir <dir>     Directory that contains input files (default: ${input_dir})
  -o, --output-dir <dir>    Directory to place output files (default: ${output_dir})
  -h, --help                Show this help message
EOF
}

options='c:i:o:h'
long_options='checker:,input:,output:,help'

OPTS=$(getopt --name "$__script_name" --options "$options" \
      --longoptions "$long_options" -- "$@")

if (( $? != 0 )); then
  printf "See '%s --help' for more information.\n" "${__script_name}" >&2
  exit 2
fi
eval set -- "$OPTS"

while true; do
  case "$1" in
    -h | --help)
      usage; exit 0 ;;
    -c | --checker)
      checker="$2"; shift 2 ;;
    -i | --input-dir)
      input_dir="$2"; shift 2 ;;
    -o | --output-dir)
      output_dir="$2"; shift 2 ;;
    --)
      shift; break ;;
    *)
      echo "Unknown option: $1" >&2; shift ;;
  esac
done

if [[ ! -f "$checker" ]]; then
  printf "Could not find checker file '%s'\n" "${checker}" >&2
  exit 2
fi

if [[ ! -d "$input_dir" ]]; then
  printf "Could not find input directory '%s'\n" "${input_dir}" >&2
  exit 2
fi

if [[ -d "$output_dir" ]]; then
  printf "Directory '%s' already exists. Overwrite? [Y/n] " "$output_dir"
  read answer
  case "$answer" in 
    y | Y)
      rm -rf "$output_dir" ;;
    *)
      printf "Aborted\n" >&2; exit 1 ;;
  esac
fi

mkdir -p "$output_dir"

if [[ "$(basename "$checker")" == "$checker" ]]; then
  checker="./${checker}"
fi

input_num=$(find "$input_dir" -iname "*.in" | wc -l)

if (( input_num == 0 )); then
  printf "No input file found in '%s'\n" "$input_dir" >&2
  printf "Aborted\n" >&2
  exit 2
fi

declare -i input_cnt=1
exec_info_file="$(mktemp)"
exec_info_format=$(cat << EOF
elapsed time:%e
memory:%M
EOF
)

trap 'rm -f "${exec_info_file}"' EXIT

exit_code=0
for input in "${input_dir}"/*.in; do
  input_basename=$(basename "$input" .in)
  output="${output_dir}/${input_basename}.out"
  echo -en " (${LIGHT_GREEN}${input_cnt}${RESET}/${MAGENTA}${input_num}${RESET}) ${input}"
  "$time_command" -f "$exec_info_format" -o "$exec_info_file" \
      "$checker" < "$input" > "$output" 2> /dev/null 

  if (( $? != 0 )); then
    echo -e "\t${B_RED}FAILED${RESET}"
    rm -f "$output"
    exit_code=1
  else
    elapsed_time=$(cat "$exec_info_file" | grep 'elapsed time' | awk -F: '{print $2}')
    memory=$(cat "$exec_info_file" | grep 'memory' | awk -F: '{print $2}')
    memory=$(( memory / 1024 ))
    echo -e "${LIGHT_BLUE}\t-->${RESET} ${output}\t${B_GREEN}OK${RESET} (${elapsed_time}s, ${memory} MB)"
  fi
  input_cnt+=1
done

exit $exit_code
